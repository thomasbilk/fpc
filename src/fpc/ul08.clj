; Funktionale Programmierung (in Clojure) Uebungen Serie 8
; Folgen
; (c) 2014 by Burkhardt Renz, THM

(ns fpc.ul08)

stop

; Aufgabe 1

; Programmieren Sie eine Funktion palindrome?, die zu einem
; String ermittelt, ob er ein Palindrom ist

(defn palindrome?
  "Test whether string s is a palindrome"
  [s]
  (= (seq s) (reverse s)))

(palindrome? "abba")
;=> true

(palindrome? "regen")
;=> false

(palindrome? "reliefpfeiler")
;=> true

; Aufgabe 2

; Programmieren Sie eine Funktion (char-cnt ch str), die die Zahl
; des Vorkommens des Buchstabens in str ermittelt

(defn char-cnt
  "Zählt die Zahl der Buchstaben ch im String str."
  [ch str]
  (reduce + (map #(if (= % ch) 1 0) (seq str))))

(char-cnt \c "abcdcde")
;=> 2

(char-cnt \a "bcde")
;=> 0

; Aufgabe 3

; Im Übungsblatt Serie 4 hatten wir die Aufgabe
; Berechnen Sie die Summe $\sum_{i=1}^n i$.

; Lösen Sie die Aufgabe mit den Kenntnissen über Clojures Folgen

(defn sum
  [n]
  (reduce + (range 1 (inc n))))

(sum 100)

; Aufgabe 4

; Lösen Sie die Aufgaben 1 (a) - (d) aus Übungsblatt Serie 6 mittels Folgen

(defn vsquare
  [vec]
  (into [] (map #(* % %) vec)))

(vsquare [1 2 3])
;=> [1 4 9]

(defn vinc
  [vec]
  (into [] (map inc vec)))

(vinc [1 2 3])
;=> [2 3 4]

(defn vmult
  [vec n]
  (into [] (map #(* n %) vec)))

(vmult [1 2 3] 2)
;=> [2 4 6]

(defn vskalarprod
  [vec1 vec2]
  (reduce + (map * vec1 vec2)))

(vskalarprod [1 2 3] [-7 8 9])
;=> 36

; Aufgabe 5

; Die erste Aufgabe im Projekt Euler (projecteuler.net) lautet:


; If we list all the natural numbers below 10 that are multiples of 3 or 5, 
; we get 3, 5, 6 and 9. The sum of these multiples is 23.

; Find the sum of all the multiples of 3 or 5 below 1000.

; Verwenden Sie Folgen in Clojure, um eine Lösung dieser Aufgabe zu programmieren

(let [sum-of (fn [d] (reduce + (range d 1000 d)))]
  (+ (sum-of 3) (sum-of 5) (- (sum-of 15))))

;=> 233168

; Aufgabe 6

; (a) Wir hatten in Serie 4 die Aufgabe die Fibonacci-Zahlen zu berechnen.
; Programmieren Sie jetzt eine verzögerte Sequenz der Fibonacci-Zahlen

(defn fib-seq []
  (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))

(take 10 (fib-seq))

; (b) Damit kann man die zweite Aufgabe im Projekt Euler lösen:
; Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
; By starting with 1 and 2, the first 10 terms will be:

; 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

; By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
; find the sum of the even-valued terms.

(reduce + 
  (filter even? (take-while #(< % 4000000) (fib-seq))))        

;=> 4613732
